
import java.util.ArrayList;
import java.util.Collections;
import org.gravity.typegraph.basic.TAbstractType;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.gravity.typegraph.basic.TFieldDefinition;
import org.gravity.typegraph.basic.TMember;
import org.gravity.typegraph.basic.TMethodDefinition;
import org.gravity.typegraph.basic.TSyntethicMethod;
import org.gravity.typegraph.basic.TVisibility;
import org.gravity.typegraph.basic.containers.ContainersFactory;

partial class TClassImpl {

@members <--

	@Override
	public String toString() {
		// TODO Auto-generated method stub
		String string = super.toString();
		return string.substring(0, string.length() - 1).concat(", name: ").concat(tName).concat(")");
	}

	private List<TClass> getParents() {
		List<TClass> parents = new ArrayList<TClass>();
		TClass parent = this.getParentClass();
		while (parent != null) {
			parents.add(parent);
			parent = parent.getParentClass();
		}
		return parents;
	}

	protected boolean hasCommonSuperType(TAbstractType tAbstractType) {
		if (!(tAbstractType instanceof TClassImpl)) {
			return false;
		}
		TClassImpl tClass = (TClassImpl) tAbstractType;

		List<TClass> parents = this.getParents();
		parents.add(this);
		List<TClass> otherParents = tClass.getParents();
		otherParents.add(tClass);

		return (!Collections.disjoint(parents, otherParents));
	}
	
-->

@model getAllTMembers () <--

		Set<TMember> allMembers = new HashSet<>();
		TClass current = this;
		while (current != null) {
			for (TMember member : current.getDefines()) {
				EList<?> redefinedBy;
				if (member instanceof TMethodDefinition) {
					TMethodDefinition method = (TMethodDefinition) member;
					redefinedBy = method.getOverriddenBy();
				} else if (member instanceof TFieldDefinition) {
					TFieldDefinition field = (TFieldDefinition) member;
					redefinedBy = field.getHiddenBy();
				} else if (member instanceof TSyntethicMethod){
					// Ignore synthetic methods
					continue;
				} else {
					throw new RuntimeException("Unknown TMember subtype.");
				}
				boolean contained = false;
				for (Object o : redefinedBy) {
					contained |= allMembers.contains(o);
				}
				if (!contained) {
					allMembers.add(member);
				}
			}
			current = current.getParentClass();
		}
		TMemberContainer container = ContainersFactory.eINSTANCE.createTMemberContainer();
		container.getTMembers().addAll(allMembers);
		return container;
-->

}