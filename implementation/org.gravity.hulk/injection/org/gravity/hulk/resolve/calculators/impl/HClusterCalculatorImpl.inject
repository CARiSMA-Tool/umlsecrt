
import org.gravity.hulk.refactoringgraph.RefactoringgraphFactory;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;
import org.gravity.typegraph.basic.TAccess;
import org.gravity.typegraph.basic.annotations.TAnnotation;
import org.gravity.typegraph.basic.TFieldDefinition;
import org.gravity.typegraph.basic.TMember;
import org.gravity.typegraph.basic.TMethodDefinition;
import com.apporiented.algorithm.clustering.AverageLinkageStrategy;
import com.apporiented.algorithm.clustering.Cluster;
import com.apporiented.algorithm.clustering.ClusteringAlgorithm;
import com.apporiented.algorithm.clustering.CompleteLinkageStrategy;
import com.apporiented.algorithm.clustering.DefaultClusteringAlgorithm;
import com.apporiented.algorithm.clustering.SingleLinkageStrategy;
import com.apporiented.algorithm.clustering.visualization.DendrogramPanel;
import org.gravity.hulk.refactoringgraph.HCluster;
import org.gravity.hulk.refactoringgraph.HMethodToDataClassAccess;

partial class HClusterCalculatorImpl {

@members <--

	private static final CLUSTERING CLUSTER = CLUSTERING.NONE;

	public enum CLUSTERING {
		BRUTFORCE, CLUSTER, NONE;
	}

	@Override
	public String getGuiName() {
		return "Connected Members";
	}
	
	private void bruteforceAlgo(TClass tClass, List<TMethodDefinition> tMethods) {
		Hashtable<TMethodDefinition, List<TClass>> dataclasses = new Hashtable<>();
		for (TMethodDefinition tMethod : tMethods) {
			for (TAnnotation tAnnotation : tMethod.getTAnnotation()) {
				if (tAnnotation instanceof HMethodToDataClassAccess) {
					HMethodToDataClassAccess dca = (HMethodToDataClassAccess) tAnnotation;
					List<TClass> dc;
					if (dataclasses.containsKey(tMethod)) {
						dc = dataclasses.get(tMethod);
					} else {
						dc = new ArrayList<>();
						dataclasses.put(tMethod, dc);
					}
					if(!dc.contains(dca.getHDataClass())){
						dc.add(dca.getHDataClass());
					}
				}
			}
		}

		fill(dataclasses, new Hashtable<TMethodDefinition,TClass>(), tClass);
	}

	private void fill(Hashtable<TMethodDefinition, List<TClass>> input, Hashtable<TMethodDefinition, TClass> output,
			TClass tClass) {
		Iterator<Entry<TMethodDefinition, List<TClass>>> iterator = input.entrySet().iterator();
		if (iterator.hasNext()) {
			Entry<TMethodDefinition, List<TClass>> entry = iterator.next();
			TMethodDefinition key = entry.getKey();
			List<TClass> values = input.remove(key);;
			for (TClass value : values) {
				List<TMethodDefinition> list;
				output.put(key, value);
				fill(input, output, tClass);
				output.remove(key);
			}
		} else {
			RefactoringgraphFactory factory = RefactoringgraphFactory.eINSTANCE;
			Hashtable<TClass, HCluster> clusters = new Hashtable<>();
			for (TMethodDefinition key : output.keySet()) {
				TClass value = output.get(key);
				HCluster hCluster;
				if(clusters.containsKey(value)){
					hCluster = clusters.get(value);
				}
				else{
					hCluster = factory.createHCluster();
					tClass.getTAnnotation().add(hCluster);
					hCluster.setTAnnotated(tClass);
					clusters.put(value, hCluster);
				}
				hCluster.getTMembers().add(key);
			}
			for(TClass tData : clusters.keySet()){
				System.out.println("Next Cluster ("+tData+"):");
				HCluster hCluster = clusters.get(tData);
				for(TMember m : hCluster.getTMembers()){
					System.out.println(m.getSignatureString() + "->" + tData.getFullyQualifiedName());
				}
			}
			System.out.println();
		}
	}

	private void clusterAlgo(TClass tClass, List<TMethodDefinition> tMethods, int size) {
		Double treshold = Math.sqrt(size);

		String[] names = new String[size];
		double[][] distances = new double[size][size];
		for (int i = 0; i < size; i++) {
			names[i] = Integer.toString(i);
			for (int j = 0; j < size; j++) {
				distances[i][j] = 0;
			}
		}

		double max = 0;
		for (int i = 0; i < size; i++) {
			for (TAccess tAccess : tMethods.get(i).getTAccessing()) {
				int j = tMethods.indexOf(tAccess.getTTarget());
				if (j >= 0) {
					double distance = distances[i][j]++;
					if (distance > max) {
						max = distance;
					}
				}
			}
		}

		max++;
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				double distance = distances[i][j];
				distances[i][j] = max - distance;
			}
		}

		ClusteringAlgorithm alg = new DefaultClusteringAlgorithm();
		Stack<Cluster> stack = new Stack<>();
		stack.add(alg.performClustering(distances, names, new CompleteLinkageStrategy()));

		RefactoringgraphFactory factory = RefactoringgraphFactory.eINSTANCE;
		List<HCluster> clusters = new ArrayList<HCluster>();

		while (!stack.isEmpty()) {
			Cluster current = stack.pop();
			stack.addAll(current.getChildren());
			if (current.getWeightValue() < 3 * treshold) {
				List<String> leafNames = new ArrayList<>();

				Stack<Cluster> collect = new Stack<Cluster>();
				collect.add(current);
				while (!collect.isEmpty()) {
					Cluster next = collect.pop();
					String name = next.getName();
					if (!name.startsWith("clstr")) {
						leafNames.add(name);
					}
					collect.addAll(next.getChildren());
				}

				HCluster cluster = factory.createHCluster();
				cluster.setValue(leafNames.size());
				for (String name : leafNames) {
					cluster.getTMembers().add(tMethods.get(Integer.parseInt(name)));
				}
				tClass.getTAnnotation().add(cluster);
				clusters.add(cluster);
			}
		}
	}
	
-->

@model detect (TClass tClass) <--

		final EList<TMember> defines = tClass.getDefines();
		List<TMethodDefinition> tMethods = new ArrayList<>();
		int size = 0;
		for (TMember tMember : defines) {
			if (tMember instanceof TMethodDefinition) {
				if (tMethods.add((TMethodDefinition) tMember)) {
					size++;
				}
			}
		}

		if (size <= 0) {
			//nothing to do
			return false;
		}

		if (CLUSTER == CLUSTERING.BRUTFORCE) {
			bruteforceAlgo(tClass, tMethods);
		} else if (CLUSTER == CLUSTERING.CLUSTER) {
			clusterAlgo(tClass, tMethods, size);
		} else {
			RefactoringgraphFactory factory = RefactoringgraphFactory.eINSTANCE;
			List<HCluster> clusters = new ArrayList<HCluster>();

			for (TMethodDefinition tMethod : tMethods) {
				HCluster cluster = factory.createHCluster();
				cluster.setValue(1);
				cluster.getTMembers().add(tMethod);
				tClass.getTAnnotation().add(cluster);
				clusters.add(cluster);
			}
		}
		return true;
-->

}